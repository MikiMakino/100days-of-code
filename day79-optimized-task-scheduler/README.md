# Day 79: 作業スケジューラ最適化アプリ

複数のタスクを**締切遅延が最小になる順番**で並べ替える最適化アプリです。
4つのアルゴリズムを比較して、計算量と精度のトレードオフを体感できます。

![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)
![Tkinter](https://img.shields.io/badge/GUI-Tkinter-green.svg)

## スクリーンショット

![アプリ画面](screenshot.png)

## 特徴

- **4つのアルゴリズムを同時比較**
  - EDF（締切順）
  - SPT（短い順）
  - EDF + ローカル探索
  - 総当たり（最適解）
- **ガントチャートで視覚化**
- **計算時間・候補数の比較表示**
- **スレッド処理**でUI固まらない

## 実行方法

```bash
python task_scheduler.py
```

### 必要環境

- Python 3.8+
- tkinter（Python標準ライブラリ）

## 使い方

1. タスクを追加（タスク名、所要時間、締切）
2. 「⚡ 最適化実行」ボタンをクリック
3. 4つのアルゴリズムの結果を比較
4. ガントチャートで視覚的に確認

## アルゴリズム解説

### 1. EDF（Earliest Deadline First）
締切が早いタスクから順に実行。
**計算量**: O(n log n) - 超高速

```python
sorted(tasks, key=lambda t: t.deadline)
```

### 2. SPT（Shortest Processing Time）
所要時間が短いタスクから順に実行。
**計算量**: O(n log n) - 超高速

```python
sorted(tasks, key=lambda t: t.duration)
```

### 3. EDF + ローカル探索（swap改善）
EDFで初期解を作り、2つのタスクを入れ替えて改善を繰り返す。
**計算量**: O(n² × 反復回数) - 現実的

### 4. 総当たり（Brute Force）
全ての順列を試して最適解を見つける。
**計算量**: O(n!) - タスク数が増えると爆発

| タスク数 | 組み合わせ数 | 実行時間目安 |
|---------|-------------|-------------|
| 5個 | 120 | 一瞬 |
| 8個 | 40,320 | 一瞬 |
| 10個 | 3,628,800 | 数秒 |
| 12個 | 479,001,600 | 数分 |

## ファイル構成

```
day79-optimization-task-scheduler/
├── task_scheduler.py    # メインアプリ
├── optimization_guide.md # アルゴリズム詳細解説
├── flowchart.md         # Mermaid形式のフローチャート
└── README.md            # このファイル
```

## 学べるポイント

### 1. 計算量の爆発
n! がいかに速く爆発するかを体感できます。
10個のタスクで約360万通り、15個で1兆通り以上。

### 2. ヒューリスティックの価値
完璧な最適解でなくても「十分良い解」を高速に得られる。
実務では「現実的な時間で得られる良い解」が重要。

### 3. トレードオフの理解
- **精度** vs **速度**
- **最適解保証** vs **実用性**

## 問題の数学的定義

**入力**: n個のタスク、各タスク i に所要時間 pᵢ と締切 dᵢ

**目的**: 総遅延 Σ max(0, Cᵢ - dᵢ) を最小化する順序を求める

（Cᵢ = タスク i の完了時刻）

この問題は **NP困難** であり、多項式時間で最適解を得るアルゴリズムは存在しないと考えられています。

## ライセンス

MIT License

## 関連リンク

- [100 Days of Code](https://github.com/your-username/100days-of-code)
