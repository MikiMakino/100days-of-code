# 作業スケジューラ最適化 - アルゴリズム解説

## 問題設定

**やりたいこと**: 複数のタスクを、締切遅延が最小になる順番で処理したい

```
入力: タスクのリスト（各タスクに所要時間と締切がある）
出力: 遅延合計が最小になる実行順序
```

---

## 基本の計算式

### タスクの定義

各タスク i は以下の属性を持つ:

| 記号 | 意味 | 例 |
|------|------|-----|
| pᵢ | 所要時間 (processing time) | 30分 |
| dᵢ | 締切 (deadline) | 60分後 |

### 完了時刻の計算

タスクを順番に実行したとき、タスク i の完了時刻 Cᵢ は:

```
C₁ = p₁
C₂ = p₁ + p₂
C₃ = p₁ + p₂ + p₃
...
Cᵢ = Σ pⱼ  (j = 1 から i まで)
```

**例**: タスクA(30分) → タスクB(15分) → タスクC(20分) の順で実行
```
C_A = 30
C_B = 30 + 15 = 45
C_C = 30 + 15 + 20 = 65
```

### 遅延（Tardiness）の計算

各タスク i の遅延 Tᵢ は:

```
Tᵢ = max(0, Cᵢ - dᵢ)
```

- 締切より早く終了 → 遅延 = 0
- 締切より遅く終了 → 遅延 = 超過分

**例**: タスクC の締切が 50分後 の場合
```
T_C = max(0, 65 - 50) = max(0, 15) = 15分遅延
```

### 目的関数（最小化したいもの）

総遅延 T_total を最小化:

```
T_total = Σ Tᵢ = Σ max(0, Cᵢ - dᵢ)  (全タスク i について)
```

---

## 4つのアプローチ

### 1. EDF（Earliest Deadline First）- 締切が早い順

**考え方**: 「締切が近いものから先にやれば、遅れにくいでしょ」

**ソート条件**:
```
タスクを dᵢ（締切）の昇順にソート

d₁ ≤ d₂ ≤ d₃ ≤ ... ≤ dₙ となるように並べる
```

**具体例**:
```
タスクA: d=30分後
タスクB: d=60分後
タスクC: d=45分後

ソート後: d_A(30) ≤ d_C(45) ≤ d_B(60)
→ A → C → B の順で実行
```

**Pythonコード**:
```python
sorted_tasks = sorted(tasks, key=lambda t: t.deadline)
```

**メリット**:
- 超シンプル（ソートするだけ）
- 計算量: O(n log n)
- リアルタイムOSで広く使われている

**デメリット**:
- 必ずしも最適解にならない
- 長いタスクが締切近いと、後ろのタスクが全部遅れる

---

### 2. SPT（Shortest Processing Time）- 短い順

**考え方**: 「短いタスクを先に片付ければ、待ち時間が減る」

**ソート条件**:
```
タスクを pᵢ（所要時間）の昇順にソート

p₁ ≤ p₂ ≤ p₃ ≤ ... ≤ pₙ となるように並べる
```

**具体例**:
```
タスクA: p=30分
タスクB: p=10分
タスクC: p=20分

ソート後: p_B(10) ≤ p_C(20) ≤ p_A(30)
→ B → C → A の順で実行
```

**Pythonコード**:
```python
sorted_tasks = sorted(tasks, key=lambda t: t.duration)
```

**なぜ平均待ち時間が最小になる？**:
```
B→C→A の場合:
  Bの完了時刻 = 10
  Cの完了時刻 = 10 + 20 = 30
  Aの完了時刻 = 10 + 20 + 30 = 60
  平均完了時刻 = (10 + 30 + 60) / 3 = 33.3分

A→C→B の場合:
  Aの完了時刻 = 30
  Cの完了時刻 = 30 + 20 = 50
  Bの完了時刻 = 30 + 20 + 10 = 60
  平均完了時刻 = (30 + 50 + 60) / 3 = 46.7分

→ SPTの方が早く終わる！
```

**メリット**:
- 平均待ち時間（フロータイム）の最小化に最適
- 計算量: O(n log n)
- 「小さい仕事から片付ける」という直感に合う

**デメリット**:
- 締切を無視している
- 長いタスクの締切が近い場合に破綻する

---

### 3. EDF + ローカル探索（swap改善）

**考え方**: 「まずEDFで並べて、2つのタスクを入れ替えて良くなるなら採用」

**アルゴリズム**:
```
1. EDFで初期解 S を作る
2. T_best = T_total(S)  // 現在の総遅延
3. 繰り返し:
     for i = 1 to n-1:
       for j = i+1 to n:
         S' = Sのi番目とj番目を入れ替えた解
         if T_total(S') < T_best:
           S = S'
           T_best = T_total(S')
           改善フラグ = True
     if 改善なし:
       終了
4. S を返す
```

**swap判定の条件**:
```
現在の順序:  [..., タスクA, ..., タスクB, ...]
入れ替え後:  [..., タスクB, ..., タスクA, ...]

判定: T_total(入れ替え後) < T_total(現在) なら採用
```

**具体例**:
```
初期解(EDF): A → B → C → D  (総遅延 = 25分)

試行1: swap(A,B) → B → A → C → D (総遅延 = 20分) → 採用！
試行2: swap(B,C) → B → C → A → D (総遅延 = 22分) → 却下
試行3: swap(B,D) → D → C → A → B (総遅延 = 18分) → 採用！
...
改善なくなったら終了
```

**Pythonコード**:
```python
def improve_by_swaps(order):
    best = order[:]
    best_delay = calculate_total_delay(best)

    while True:
        improved = False
        for i in range(len(best)):
            for j in range(i+1, len(best)):
                trial = best[:]
                trial[i], trial[j] = trial[j], trial[i]  # swap
                if calculate_total_delay(trial) < best_delay:
                    best = trial
                    best_delay = calculate_total_delay(trial)
                    improved = True
                    break
            if improved:
                break
        if not improved:
            break
    return best
```

**メリット**:
- EDFより良い解が見つかりやすい
- 計算量: O(n² × 反復回数) → まだ現実的
- 「良い初期解 + 微調整」という実用的なアプローチ

**デメリット**:
- 局所最適に陥る可能性（山を登りきれない）
- 最適解の保証はない

---

### 4. 総当たり（Brute Force）- 全順列探索

**考え方**: 「全パターン試せば、絶対に最適解が見つかる」

**探索空間のサイズ**:
```
n個のタスクの並べ方 = n! 通り

n! = n × (n-1) × (n-2) × ... × 2 × 1
```

| n | n! | 1秒100万回計算で |
|---|-----|------------------|
| 3 | 6 | 一瞬 |
| 5 | 120 | 一瞬 |
| 8 | 40,320 | 0.04秒 |
| 10 | 3,628,800 | 3.6秒 |
| 12 | 479,001,600 | 8分 |
| 15 | 1,307,674,368,000 | 15日 |

**アルゴリズム**:
```
1. T_best = ∞, S_best = null
2. for 全ての順列 π ∈ Permutations(タスク集合):
     T = T_total(π)  // この順列の総遅延を計算
     if T < T_best:
       T_best = T
       S_best = π
3. S_best を返す
```

**具体例** (3タスクの場合):
```
タスク: A(p=10, d=15), B(p=20, d=25), C(p=15, d=30)

全6通りを試す:
  A→B→C: T = max(0,10-15) + max(0,30-25) + max(0,45-30) = 0+5+15 = 20
  A→C→B: T = max(0,10-15) + max(0,25-30) + max(0,45-25) = 0+0+20 = 20
  B→A→C: T = max(0,20-25) + max(0,30-15) + max(0,45-30) = 0+15+15 = 30
  B→C→A: T = max(0,20-25) + max(0,35-30) + max(0,45-15) = 0+5+30 = 35
  C→A→B: T = max(0,15-30) + max(0,25-15) + max(0,45-25) = 0+10+20 = 30
  C→B→A: T = max(0,15-30) + max(0,35-25) + max(0,45-15) = 0+10+30 = 40

最適解: A→B→C または A→C→B (総遅延 = 20)
```

**Pythonコード**:
```python
from itertools import permutations

def brute_force(tasks):
    best_order = None
    best_delay = float('inf')

    for perm in permutations(tasks):
        delay = calculate_total_delay(list(perm))
        if delay < best_delay:
            best_delay = delay
            best_order = list(perm)

    return best_order
```

**メリット**:
- 確実に最適解が得られる（グローバル最適）
- 実装がシンプル

**デメリット**:
- 計算量: O(n! × n) → 爆発する
- 現実的には10個程度が限界

---

## 計算量の比較

| アルゴリズム | 計算量 | 5タスク | 10タスク | 15タスク |
|-------------|--------|---------|----------|----------|
| EDF | O(n log n) | 一瞬 | 一瞬 | 一瞬 |
| SPT | O(n log n) | 一瞬 | 一瞬 | 一瞬 |
| EDF+改善 | O(n² × iter) | 一瞬 | 一瞬 | 数秒 |
| 総当たり | O(n!) | 一瞬 | 数秒 | 数時間〜 |

---

## 実務での使い分け

### タスクが少ない（〜8個）
→ **総当たり**で最適解を得る

### タスクが中程度（8〜15個）
→ **EDF+改善**でほぼ最適な解を得る

### タスクが多い（15個〜）
→ **EDF**か**SPT**で高速に「それなりの解」を得る

---

## 学びのポイント

### 1. 計算量の爆発を体感する
- n! は想像以上に速く爆発する
- 「全部試す」は小さい問題でしか通用しない

### 2. ヒューリスティックの価値
- 完璧でなくても「十分良い解」を高速に得られる
- 実務では「最適解」より「現実的な時間で得られる良い解」

### 3. 問題の性質を理解する
- この問題（1マシン総遅延最小化）はNP困難
- 多項式時間で最適解を得るアルゴリズムは存在しない（と考えられている）

---

## 発展的なトピック

さらに学びたい場合:

- **動的計画法**: 特定の条件下で効率的に解ける
- **分枝限定法**: 総当たりを賢く枝刈り
- **遺伝的アルゴリズム**: 進化的に良い解を探索
- **シミュレーテッドアニーリング**: 局所最適から脱出
