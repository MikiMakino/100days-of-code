# 学習ガイド - スケジュール最適化入門

## Day 79 との違い

Day 79 では「遅れた時間の合計を減らす」という1つの目標だけでした。Day 80 では、4つの目標から選べるようになっています。

| 項目 | Day 79 | Day 80 |
|-----|--------|--------|
| 目標 | 遅れ時間の合計だけ | 4種類から選べる |
| 結果 | 1つの目標で比較 | すべての目標の値を表示 |
| 学べること | アルゴリズムの速さと精度 | 目標が変わると答えも変わる |

**ポイント**: 同じタスクでも「何を減らしたいか」によって、最適な順番は変わります。

---

## 最適化とは

最適化とは「一番良いやり方を見つけること」です。

例えば、駅から自宅への帰り道。

- 最短時間で帰りたい → 近道を選ぶ
- 坂道を避けたい → 平坦な道を選ぶ
- コンビニに寄りたい → コンビニ経由の道を選ぶ

「何を優先するか」で選ぶ道が変わりますよね。これが最適化の基本的な考え方です。

このアプリでは「複数の作業を、どの順番でやれば一番良いか」を計算します。

---

## 4つの目標

「一番良い」の基準を **目的関数** と呼びます。このアプリでは4つから選べます。

### 1. 遅延時間（遅れた時間の合計）

それぞれの作業が締切からどれだけ遅れたかを合計します。

```
例：
・作業A：締切に間に合った → 遅れ 0分
・作業B：10分遅れた → 遅れ 10分
・作業C：5分遅れた → 遅れ 5分

合計 = 0 + 10 + 5 = 15分
```

この15分をできるだけ小さくしたい、という目標です。

### 2. 遅延タスク数（遅れた作業の数）

締切に遅れた作業が何個あるかを数えます。

```
例：
・作業A：間に合った
・作業B：遅れた ← カウント
・作業C：遅れた ← カウント

遅れた数 = 2個
```

どれだけ遅れたかは気にせず、「遅れた個数」だけを減らしたいときに使います。

### 3. 最大遅延（一番遅れた作業の遅れ）

一番ひどく遅れた作業の遅れ時間です。

```
例：
・作業A：0分遅れ
・作業B：30分遅れ ← これが最大
・作業C：5分遅れ

最大遅延 = 30分
```

「1つでも大きく遅れると困る」という場合に使います。

### 4. 完了時刻（終わった時刻の合計）

それぞれの作業が終わった時刻を合計します。

```
例：開始を0分として
・作業A：20分後に終了
・作業B：35分後に終了
・作業C：50分後に終了

合計 = 20 + 35 + 50 = 105分
```

平均的な待ち時間を短くしたいときに使います。

---

## 4つの解き方

### 1. 全部試す方法（総当たり）

すべての順番を試して、一番良いものを選びます。

- **良い点**: 必ず最良の答えが見つかる
- **悪い点**: 作業が増えると計算量が爆発する

作業の数と、試す順番の数：

| 作業数 | 試す数 |
|-------|-------|
| 3個 | 6通り |
| 5個 | 120通り |
| 10個 | 約360万通り |
| 15個 | 約1兆通り |

なぜこんなに増えるのか？作業が n 個のとき、順番は n! （階乗）通りあります。

```
5! = 5 × 4 × 3 × 2 × 1 = 120
10! = 10 × 9 × 8 × ... × 1 = 3,628,800
```

### 2. 締切が早い順（EDF）

締切が近い作業から先にやる、というシンプルなルールです。

```
例：
・レポート（締切60分後）
・メール（締切30分後）← 先にやる
・準備（締切45分後）

順番：メール → 準備 → レポート
```

**特徴**: 「最大遅延」を最小にする場合、このルールが最良の答えを出します。

### 3. 短い作業から先に（SPT）

時間がかからない作業から先にやる、というルールです。

```
例：
・レポート（30分かかる）
・メール（10分かかる）← 先にやる
・準備（20分かかる）

順番：メール → 準備 → レポート
```

**特徴**: 「完了時刻の合計」を最小にする場合、このルールが最良の答えを出します。

### 4. 締切順 ＋ 改善（EDF + Swap）

1. まず締切順で並べる
2. 2つの作業を入れ替えてみる
3. 良くなったら採用、悪くなったら元に戻す
4. 改善がなくなるまで繰り返す

総当たりより速く、単純なルールより良い答えが見つかることが多い方法です。

---

## 計算量について

### なぜ「全部試す」が難しくなるのか

作業が少し増えるだけで、計算量が急激に増えます。

- 5個 → 120通り（一瞬で終わる）
- 10個 → 360万通り（数秒かかる）
- 15個 → 1兆通り（現実的に無理）

このように、問題のサイズが少し大きくなるだけで計算が爆発的に増える問題を **NP困難** と呼びます。

### 現実ではどうするか

- **少ない場合**: 全部試して最良を見つける
- **多い場合**: ルールや改善で「十分良い答え」を見つける

完璧な答えより、速く見つかる「ほぼ正解」の方が実用的なことも多いです。

---

## このアプリで確認できること

### 1. 目標が変わると答えが変わる

同じ作業でも、「遅延時間」を選んだときと「完了時刻」を選んだときで、最適な順番が違います。

### 2. 速さと精度のバランス

| 方法 | 速さ | 精度 |
|-----|-----|-----|
| EDF / SPT | とても速い | 特定の目標では最良 |
| EDF + 改善 | 速い | 多くの場合で良好 |
| 総当たり | 遅い | 必ず最良 |

### 3. 作業数と計算時間の関係

作業を7個、8個、9個と増やしていくと、総当たりの計算時間がどんどん長くなる様子を観察できます。

---

## 試してみよう

1. サンプルのままで「遅延時間」を最小化 → 結果を確認
2. 「完了時刻」に切り替えて最小化 → 順番が変わった？
3. 作業を10個まで増やして最適化 → 計算時間は？
4. 「EDF + 改善」と「総当たり」の結果を比較 → 同じ？違う？

---

## 用語まとめ

| 用語 | 意味 |
|-----|-----|
| 目的関数 | 「何を良いとするか」を決める計算式 |
| 総当たり | すべての可能性を試す方法 |
| EDF | 締切が早い順に処理するルール |
| SPT | 時間が短い順に処理するルール |
| ローカル探索 | 少しずつ改善を繰り返す方法 |
| 階乗 (n!) | n × (n-1) × ... × 1 の計算 |
| NP困難 | 規模が大きくなると計算が爆発する問題 |
